function [rhsh] = real_ghost(rhsh)
% real_ghost(rhsh) - modifies the coefficients of the expansion over
%   the real harmonics to remove regions of negative probability
%   density. Returns the modified coefficients in the cell array rhsh,
%   where the index of the cell corresponds to N/2+1 and the coefficients 
%   within the cell are ordered by increasing L, decreasing M for a given 
%   L, and with C before S for a given M.
%
% rhsh - a cell array storing the coefficients of the expansion. The index
%   of the cell corresponds to N/2+1 and the coefficients within the cell
%   are ordered by increasing L, decreasing M for a given L, and with C
%   before S for a given M.
% N_max - maximum principal order of the symmetrized harmonics used
% pts - resolution of the symmetrized harmonics as generated by
%   symm_construct
% A, a - beta, or half of the rotation angle
% B, b - theta, or the polar angle in spherical coordinates
% C, c - phi, or the azimuthal angle in spherical coordinates
% dp - the invariant Haar measure for the space of normalized quaternions
% output - the values of the function expressed by the coefficients in shsh
% error - the portion of output for negative values, inverted in sign to be
%   positive
% 
% 
% Copyright (c) 2013, Lawrence Livermore National Security, LLC.  Produced
% at the Lawrence Livermore National Laboratory.  Written by Jeremy Mason,
% reachable at mason47@llnl.gov.
% 
% CODE-609912. All rights reserved.
% 
% This file is part of the Quaternionic Harmonic Analysis of Texture.  
% Please read LICENSE.txt for Our Notice and GNU General Public License
% information.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License (as published by
% the Free Software Foundation) version 2, dated June 1991.
% 
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
% conditions of the GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License along
% with this program; if not, write to the Free Software Foundation, Inc.,
% 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

N_max = 2*(size(rhsh,1)-1);

pts = 200;

a = zeros(pts,pts/2,pts/2);
b = zeros(pts,pts/2,pts/2);
c = zeros(pts,pts/2,pts/2);
p = zeros(pts,pts/2,pts/2);
g = zeros(pts,pts/2,pts/2);

A = linspace(0,pi,pts/2);
B = linspace(0,pi,pts/2);
C = linspace(0,2*pi,pts);
for j = 1:pts/2
    a(:,:,j) = A(j);
    b(:,j,:) = B(j);
end
for j = 1:pts
    c(j,:,:) = C(j);
end
dp = sin(a(1:end-1,1:end-1,1:end-1)+diff(A(1:2))/2).^2.*sin(b(1:end-1,1:end-1,1:end-1)+diff(B(1:2))/2)*diff(A(1:2))*diff(B(1:2))*diff(C(1:2));

output = zeros(pts,pts/2,pts/2);
for N = 0:2:N_max
    disp(N);
    for L = 0:N
        for M = 0:L
            G = zeros(size(A));
            for s = 0:N-L
                G = G+((prod((L+1):(L+s))*prod((N-L-s+1):(N-s)))/prod(1:s))*cos((2*s-N+L)*A);
            end
            G = 2^(L+1/2)*realsqrt((N+1)/(pi*prod((N-L+1):(N+L+1))))*sin(A).^L.*G;
            P = legendre(L,cos(B));
            for s = 1:pts/2
                g(:,:,s) = G(s);
                p(:,s,:) = P(M+1,s);
            end
            
            if M > 0.5
                output = output+rhsh{N/2+1}((L+1)^2-2*M)*(-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*cos(M*c);
                output = output+rhsh{N/2+1}((L+1)^2-2*M+1)*(-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*sin(M*c);
            else
                output = output+rhsh{N/2+1}((L+1)^2)*(-1)^L*realsqrt((2*L+1)/(4*pi))*g.*p;
            end
        end
    end
end

out_min = min(output(output<0));
out_max = max(output(output>0));
disp(abs(out_max/out_min));
while ~isempty(out_min) && abs(out_max/out_min) < 10
    error = -output;
    error(error<0) = 0;
    
    scale = rhsh{1}(1);
    for N = 0:2:N_max
        disp(N);
        for L = 0:N
            for M = 0:L
                G = zeros(size(A));
                for s = 0:N-L
                    G = G+((prod((L+1):(L+s))*prod((N-L-s+1):(N-s)))/prod(1:s))*cos((2*s-N+L)*A);
                end
                G = 2^(L+1/2)*realsqrt((N+1)/(pi*prod((N-L+1):(N+L+1))))*sin(A).^L.*G;
                P = legendre(L,cos(B));
                for s = 1:pts/2
                    g(:,:,s) = G(s);
                    p(:,s,:) = P(M+1,s);
                end

                if M > 0.5
                    Y = error.*((-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*cos(M*c));
                    Y = (Y(1:end-1,1:end-1,1:end-1)+Y(2:end,1:end-1,1:end-1)+Y(1:end-1,2:end,1:end-1)+Y(1:end-1,1:end-1,2:end)+Y(2:end,2:end,1:end-1)+Y(2:end,1:end-1,2:end)+Y(1:end-1,2:end,2:end)+Y(2:end,2:end,2:end))/8;
                    rhsh{N/2+1}((L+1)^2-2*M) = rhsh{N/2+1}((L+1)^2-2*M)+sum(sum(sum(Y.*dp)));
                    Y = error.*((-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*sin(M*c));
                    Y = (Y(1:end-1,1:end-1,1:end-1)+Y(2:end,1:end-1,1:end-1)+Y(1:end-1,2:end,1:end-1)+Y(1:end-1,1:end-1,2:end)+Y(2:end,2:end,1:end-1)+Y(2:end,1:end-1,2:end)+Y(1:end-1,2:end,2:end)+Y(2:end,2:end,2:end))/8;
                    rhsh{N/2+1}((L+1)^2-2*M+1) = rhsh{N/2+1}((L+1)^2-2*M+1)+sum(sum(sum(Y.*dp)));
                else
                    Y = error.*((-1)^L*realsqrt((2*L+1)/(4*pi))*g.*p);
                    Y = (Y(1:end-1,1:end-1,1:end-1)+Y(2:end,1:end-1,1:end-1)+Y(1:end-1,2:end,1:end-1)+Y(1:end-1,1:end-1,2:end)+Y(2:end,2:end,1:end-1)+Y(2:end,1:end-1,2:end)+Y(1:end-1,2:end,2:end)+Y(2:end,2:end,2:end))/8;
                    rhsh{N/2+1}((L+1)^2) = rhsh{N/2+1}((L+1)^2)+sum(sum(sum(Y.*dp)));
                end
            end
        end
    end
    scale = scale/rhsh{1}(1);
    for N = 0:2:N_max
        rhsh{N/2+1} = rhsh{N/2+1}*scale;
    end
    
    output = zeros(pts,pts/2,pts/2);
    for N = 0:2:N_max
        disp(N);
        for L = 0:N
            for M = 0:L
                G = zeros(size(A));
                for s = 0:N-L
                    G = G+((prod((L+1):(L+s))*prod((N-L-s+1):(N-s)))/prod(1:s))*cos((2*s-N+L)*A);
                end
                G = 2^(L+1/2)*realsqrt((N+1)/(pi*prod((N-L+1):(N+L+1))))*sin(A).^L.*G;
                P = legendre(L,cos(B));
                for s = 1:pts/2
                    g(:,:,s) = G(s);
                    p(:,s,:) = P(M+1,s);
                end

                if M > 0.5
                    output = output+rhsh{N/2+1}((L+1)^2-2*M)*(-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*cos(M*c);
                    output = output+rhsh{N/2+1}((L+1)^2-2*M+1)*(-1)^(M)*realsqrt((2*L+1)/(2*pi*prod((L-M+1):(L+M))))*g.*p.*sin(M*c);
                else
                    output = output+rhsh{N/2+1}((L+1)^2)*(-1)^L*realsqrt((2*L+1)/(4*pi))*g.*p;
                end
            end
        end
    end
    
    out_min = min(output(output<0));
    out_max = max(output(output>0));
    disp(abs(out_max/out_min));
end
